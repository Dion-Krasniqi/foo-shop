{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * @module missionlog\n * @author Ray Martone\n * @copyright Copyright (c) 2019-2025 Ray Martone\n * @license MIT\n * @description A lightweight TypeScript logger with level-based filtering and tagging.\n * Drop-in replacement for console.log with additional categorization and filtering capabilities.\n */\n\n/**\n * Internal log levels enum\n */\nenum Level {\n  TRACE = 1,\n  DEBUG,\n  INFO,\n  WARN,\n  ERROR,\n  OFF,\n}\n\n/**\n * Public log levels enum for external use\n */\nexport enum LogLevel {\n  TRACE = 'TRACE',\n  DEBUG = 'DEBUG',\n  INFO = 'INFO',\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n  OFF = 'OFF',\n}\n\n/** Valid log level strings */\nexport type LogLevelStr = 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'OFF';\n\n/** Supported message types for logging */\nexport type LogMessage = string | number | boolean | object | Error | null | undefined;\n\n/** Callback function invoked for each log message */\nexport type LogCallback = (level: LogLevelStr, tag: string, message: unknown, optionalParams: unknown[]) => void;\n\n/** Configuration mapping tags to log levels */\nexport interface LogConfig {\n  [tag: string]: LogLevelStr;\n}\n\n/** Default tag used for untagged logging and wildcard configuration */\nexport const DEFAULT_TAG = '*';\nconst tagRegistry = new Set<string>();\n\n/**\n * Proxy for type-safe tag access with runtime validation.\n * Returns the tag name if registered, undefined otherwise.\n */\nexport const tag: Record<string, string> = new Proxy(\n  {},\n  {\n    get(_, prop: string) {\n      if (typeof prop === 'string' && tagRegistry.has(prop)) {\n        return prop;\n      }\n      return undefined;\n    },\n    ownKeys() {\n      return Array.from(tagRegistry);\n    },\n    getOwnPropertyDescriptor() {\n      return { enumerable: true, configurable: true };\n    },\n  },\n);\n\n// Level enum to string conversion\nconst LEVEL_STR_MAP = new Map<Level, LogLevelStr>([\n  [Level.TRACE, 'TRACE'],\n  [Level.DEBUG, 'DEBUG'],\n  [Level.INFO, 'INFO'],\n  [Level.WARN, 'WARN'],\n  [Level.ERROR, 'ERROR'],\n  [Level.OFF, 'OFF'],\n]);\n\n// String to level enum conversion\nconst STR_TO_LEVEL_MAP = new Map<LogLevelStr, Level>([\n  ['TRACE', Level.TRACE],\n  ['DEBUG', Level.DEBUG],\n  ['INFO', Level.INFO],\n  ['WARN', Level.WARN],\n  ['ERROR', Level.ERROR],\n  ['OFF', Level.OFF],\n]);\n\nconst DEFAULT_LEVEL = Level.INFO;\nconst FALLBACK_LEVEL = Level.DEBUG;\nconst EMPTY_ARRAY: readonly unknown[] = [];\n\n/**\n * Main logging class with level-based filtering and tagging support\n */\nexport class Log {\n  private _defaultLevel: Level = DEFAULT_LEVEL;\n  protected readonly _tagToLevel = new Map<string, Level>();\n  private readonly _levelCache = new Map<Level, Map<string, boolean>>();\n  protected _callback?: LogCallback | null;\n\n  /**\n   * Initialize logger with tag levels and callback\n   * @param config - Map of tags to log levels\n   * @param callback - Callback function for log processing\n   * @returns this for method chaining\n   */\n  init(config?: Record<string, string> | LogConfig, callback?: LogCallback | null): this {\n    this._levelCache.clear();\n\n    if (config) {\n      for (const key in config) {\n        const levelStr = config[key] as LogLevelStr;\n        this._setTagLevel(key, levelStr);\n      }\n    }\n\n    if (callback !== undefined) {\n      this._callback = callback;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set log level for a tag\n   */\n  private _setTagLevel(tag: string, levelStr: LogLevelStr): void {\n    const level = STR_TO_LEVEL_MAP.get(levelStr);\n\n    if (level !== undefined) {\n      if (tag === DEFAULT_TAG) {\n        this._defaultLevel = level;\n      } else {\n        this._tagToLevel.set(tag, level);\n        tagRegistry.add(tag);\n      }\n    } else {\n      console.warn(\n        `Invalid log level \"${levelStr}\" for tag \"${tag}\". Using default (${LEVEL_STR_MAP.get(this._defaultLevel)}).`,\n      );\n      this._tagToLevel.set(tag, FALLBACK_LEVEL);\n      tagRegistry.add(tag);\n    }\n  }\n\n  /**\n   * Check if logging is enabled for level and tag (cached)\n   */\n  private _shouldLog(level: Level, tag: string): boolean {\n    let levelMap = this._levelCache.get(level);\n    if (!levelMap) {\n      levelMap = new Map<string, boolean>();\n      this._levelCache.set(level, levelMap);\n    }\n\n    const normalizedTag = tag || DEFAULT_TAG;\n    const cached = levelMap.get(normalizedTag);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const effectiveLevel = this._tagToLevel.get(normalizedTag) ?? this._defaultLevel;\n    const shouldLog = level >= effectiveLevel;\n\n    levelMap.set(normalizedTag, shouldLog);\n    return shouldLog;\n  }\n\n  /**\n   * Internal logging implementation\n   */\n  private _log(level: Level, messageOrTag?: unknown, ...optionalParams: unknown[]): void {\n    if (!this._callback || messageOrTag === undefined) return;\n\n    let tag: string;\n    let message: unknown;\n    let params: unknown[];\n\n    if (typeof messageOrTag === 'string' && tagRegistry.has(messageOrTag)) {\n      tag = messageOrTag;\n      message = optionalParams[0];\n      params = optionalParams.slice(1);\n    } else {\n      tag = DEFAULT_TAG;\n      message = messageOrTag;\n      params = optionalParams;\n    }\n\n    if (message === undefined || message === '') return;\n    if (!this._shouldLog(level, tag)) return;\n\n    const filteredParams = params.length > 0 ? params.filter(param => param !== undefined) : (EMPTY_ARRAY as unknown[]);\n\n    const levelStr = LEVEL_STR_MAP.get(level)!;\n\n    const outputTag = tag === DEFAULT_TAG ? '' : tag;\n    this._callback(levelStr, outputTag, message, filteredParams);\n  }\n\n  /**\n   * Log a message at DEBUG level\n   * @param messageOrTag - Message to log, or tag if second parameter is provided\n   * @param optionalParams - Additional parameters to log\n   * @returns this for method chaining\n   */\n  public debug(messageOrTag?: unknown, ...optionalParams: unknown[]): this {\n    this._log(Level.DEBUG, messageOrTag, ...optionalParams);\n    return this;\n  }\n\n  /**\n   * Log a message at ERROR level\n   * @param messageOrTag - Message to log, or tag if second parameter is provided\n   * @param optionalParams - Additional parameters to log\n   * @returns this for method chaining\n   */\n  public error(messageOrTag?: unknown, ...optionalParams: unknown[]): this {\n    this._log(Level.ERROR, messageOrTag, ...optionalParams);\n    return this;\n  }\n\n  /**\n   * Log a message at INFO level\n   * @param messageOrTag - Message to log, or tag if second parameter is provided\n   * @param optionalParams - Additional parameters to log\n   * @returns this for method chaining\n   */\n  public info(messageOrTag?: unknown, ...optionalParams: unknown[]): this {\n    this._log(Level.INFO, messageOrTag, ...optionalParams);\n    return this;\n  }\n\n  /**\n   * Log a message at INFO level (alias for info)\n   * @param messageOrTag - Message to log, or tag if second parameter is provided\n   * @param optionalParams - Additional parameters to log\n   * @returns this for method chaining\n   */\n  public log(messageOrTag?: unknown, ...optionalParams: unknown[]): this {\n    this._log(Level.INFO, messageOrTag, ...optionalParams);\n    return this;\n  }\n\n  /**\n   * Log a message at TRACE level\n   * @param messageOrTag - Message to log, or tag if second parameter is provided\n   * @param optionalParams - Additional parameters to log\n   * @returns this for method chaining\n   */\n  public trace(messageOrTag?: unknown, ...optionalParams: unknown[]): this {\n    this._log(Level.TRACE, messageOrTag, ...optionalParams);\n    return this;\n  }\n\n  /**\n   * Log a message at WARN level\n   * @param messageOrTag - Message to log, or tag if second parameter is provided\n   * @param optionalParams - Additional parameters to log\n   * @returns this for method chaining\n   */\n  public warn(messageOrTag?: unknown, ...optionalParams: unknown[]): this {\n    this._log(Level.WARN, messageOrTag, ...optionalParams);\n    return this;\n  }\n\n  /**\n   * Check if level would be logged for tag\n   * @param level - The log level to check\n   * @param tag - The tag to check (defaults to DEFAULT_TAG)\n   * @returns true if the level would be logged for the tag\n   */\n  public isLevelEnabled(level: LogLevelStr, tag: string = DEFAULT_TAG): boolean {\n    const numericLevel = STR_TO_LEVEL_MAP.get(level);\n    if (numericLevel === undefined) return false;\n    return this._shouldLog(numericLevel, tag);\n  }\n\n  /**\n   * Check if DEBUG level is enabled for a tag\n   * @param tag - The tag to check (defaults to DEFAULT_TAG)\n   * @returns true if DEBUG level is enabled for the tag\n   */\n  public isDebugEnabled(tag: string = DEFAULT_TAG): boolean {\n    return this.isLevelEnabled(LogLevel.DEBUG, tag);\n  }\n\n  /**\n   * Check if TRACE level is enabled for a tag\n   * @param tag - The tag to check (defaults to DEFAULT_TAG)\n   * @returns true if TRACE level is enabled for the tag\n   */\n  public isTraceEnabled(tag: string = DEFAULT_TAG): boolean {\n    return this.isLevelEnabled(LogLevel.TRACE, tag);\n  }\n\n  /**\n   * Reset logger to initial state\n   * @returns this for method chaining\n   */\n  public reset(): this {\n    this._tagToLevel.clear();\n    this._levelCache.clear();\n    this._defaultLevel = DEFAULT_LEVEL;\n    this._callback = undefined;\n    tagRegistry.clear();\n    return this;\n  }\n}\n\n/** Default logger instance ready for immediate use */\nexport const log = new Log();\n"],
  "mappings": "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",
  "names": ["LogLevel", "DEFAULT_TAG", "tagRegistry", "tag", "_", "prop", "LEVEL_STR_MAP", "STR_TO_LEVEL_MAP", "DEFAULT_LEVEL", "FALLBACK_LEVEL", "EMPTY_ARRAY", "Log", "config", "callback", "key", "levelStr", "level", "levelMap", "normalizedTag", "cached", "effectiveLevel", "shouldLog", "messageOrTag", "optionalParams", "message", "params", "filteredParams", "param", "outputTag", "numericLevel", "log"]
}
